. "$(dirname -- "$0")/_/husky.sh"

echo "üîç Running pre-push checks..."
echo ""

# Check branch name follows git-flow format
echo "üåø Checking branch name format..."

branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

# Allowed branch patterns:
# - main, master, develop (main branches)
# - feature/feature-name
# - bugfix/bug-name
# - hotfix/hotfix-name
# - release/release-name
# - chore/chore-name
# - docs/docs-name
# - refactor/refactor-name
# - test/test-name
# - perf/perf-name
# - ci/ci-name
# - build/build-name

if [ -z "$branch_name" ]; then
  echo "‚ùå Could not determine branch name"
  exit 1
fi

# Check if trying to push directly to protected branches
if [ "$branch_name" = "main" ] || [ "$branch_name" = "master" ] || [ "$branch_name" = "develop" ]; then
  echo "‚ùå Direct pushes to protected branch '$branch_name' are not allowed!"
  echo ""
  echo "Protected branches: main, master, develop"
  echo ""
  echo "All changes to protected branches must come via:"
  echo "  - Pull requests from feature/bugfix/hotfix branches"
  echo "  - Merged pull requests (not direct pushes)"
  echo ""
  echo "Please create a feature branch instead:"
  echo "  git checkout -b feature/your-feature-name"
  echo ""
  echo "Or if you're on a protected branch, switch to a feature branch:"
  echo "  git checkout -b feature/your-feature-name"
  echo ""
  exit 1
else
  # Check if branch follows git-flow format
  pattern="^(feature|bugfix|hotfix|release|chore|docs|refactor|test|perf|ci|build)/.+"

  if ! echo "$branch_name" | grep -qE "$pattern"; then
    echo "‚ùå Branch name '$branch_name' does not follow git-flow format!"
    echo ""
    echo "Branch names must follow the format: <type>/<name>"
    echo ""
    echo "Allowed types:"
    echo "  feature  - New features"
    echo "  bugfix   - Bug fixes"
    echo "  hotfix   - Hotfixes"
    echo "  release  - Release branches"
    echo "  chore    - Maintenance tasks"
    echo "  docs     - Documentation changes"
    echo "  refactor - Code refactoring"
    echo "  test     - Test-related changes"
    echo "  perf     - Performance improvements"
    echo "  ci       - CI/CD changes"
    echo "  build    - Build system changes"
    echo ""
    echo "Main branches (main, master, develop) are also allowed."
    echo ""
    echo "Examples:"
    echo "  ‚úÖ feature/add-user-authentication"
    echo "  ‚úÖ bugfix/fix-indexeddb-connection"
    echo "  ‚úÖ hotfix/critical-security-patch"
    echo "  ‚ùå my-feature"
    echo "  ‚ùå add-user-auth"
    echo "  ‚ùå feature_add_user_auth"
    echo ""
    echo "To rename your current branch:"
    echo "  git branch -m <type>/<new-name>"
    echo ""
    exit 1
  fi

  echo "‚úÖ Branch '$branch_name' follows git-flow format"
fi

echo ""

# Check for linear commit history (no merge commits)
echo "üìä Checking commit history..."

remote_name="${1:-origin}"
has_stdin=false

# Pre-push hook receives input via stdin in format:
# <local_ref> <local_sha> <remote_ref> <remote_sha>
# Check if stdin has data
if [ -t 0 ]; then
  # No stdin, check current branch
  branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  if [ -n "$branch_name" ]; then
    remote_branch="refs/remotes/${remote_name}/${branch_name}"
    if git rev-parse --verify "$remote_branch" >/dev/null 2>&1; then
      base_commit=$(git merge-base "$remote_branch" HEAD)
      commit_range="${base_commit}..HEAD"
    else
      # New branch, check all commits
      commit_range="HEAD"
    fi
    has_stdin=false
  fi
else
  # Has stdin, process each ref being pushed
  while read -r local_ref local_sha remote_ref remote_sha; do
    has_stdin=true
    # Skip if this is a delete operation
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
      continue
    fi

    # Skip if this is a new branch (no local sha)
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
      continue
    fi

    # Get the branch name from the ref
    branch_name=$(echo "$local_ref" | sed 's|refs/heads/||')

    # Determine the commit range to check
    if [ "$remote_sha" != "0000000000000000000000000000000000000000" ]; then
      # Branch exists on remote, check commits between remote and local
      base_commit="$remote_sha"
      commit_range="${base_commit}..${local_sha}"
    else
      # New branch, check all commits up to the local sha
      commit_range="$local_sha"
    fi

    # Check for merge commits in the range
    merge_commits=$(git log --merges --oneline "$commit_range" 2>/dev/null | wc -l | tr -d ' ')

    if [ "$merge_commits" -gt 0 ]; then
      echo "‚ùå Merge commits detected in branch '$branch_name'! Linear commit history is required."
      echo ""
      echo "Found $merge_commits merge commit(s):"
      git log --merges --oneline "$commit_range" 2>/dev/null
      echo ""
      echo "To fix this:"
      echo "  1. Use 'git rebase' instead of 'git merge' when updating your branch"
      echo "  2. Rebase your branch: git rebase ${remote_name}/${branch_name}"
      if [ "$remote_sha" != "0000000000000000000000000000000000000000" ]; then
        echo "  3. Or use interactive rebase: git rebase -i ${base_commit}"
      fi
      echo ""
      exit 1
    fi
  done
fi

# If no stdin was processed, check the current branch
if [ "$has_stdin" = false ] && [ -n "$branch_name" ]; then
  merge_commits=$(git log --merges --oneline "$commit_range" 2>/dev/null | wc -l | tr -d ' ')

  if [ "$merge_commits" -gt 0 ]; then
    echo "‚ùå Merge commits detected in branch '$branch_name'! Linear commit history is required."
    echo ""
    echo "Found $merge_commits merge commit(s):"
    git log --merges --oneline "$commit_range" 2>/dev/null
    echo ""
    echo "To fix this:"
    echo "  1. Use 'git rebase' instead of 'git merge' when updating your branch"
    echo "  2. Rebase your branch: git rebase ${remote_name}/${branch_name}"
    if [ -n "$base_commit" ]; then
      echo "  3. Or use interactive rebase: git rebase -i ${base_commit}"
    fi
    echo ""
    exit 1
  fi
fi

echo "‚úÖ Commit history is linear"
echo ""

echo "üìù Running linter..."
pnpm lint || {
  echo "‚ùå Linting failed. Please fix the errors before pushing."
  exit 1
}

echo ""
echo "üß™ Running unit tests..."
pnpm test || {
  echo "‚ùå Unit tests failed. Please fix the tests before pushing."
  exit 1
}

echo ""
echo "üé≠ Running e2e tests..."
pnpm e2e || {
  echo "‚ùå E2E tests failed. Please fix the tests before pushing."
  exit 1
}

echo ""
echo "‚úÖ All checks passed! Proceeding with push..."

